;;; Functions

(defmacro defun (sym params & body)
  `(def ~sym (lambda ~params ~@body)))

;;; read/eval/apply

(defun read (str) (.ParseForm *parser* str))
(defun eval (form) (.Evaluate *evaluator* form))
(defun apply (fun & args) (.Apply *applier* fun args))

;;; Control flow

(defmacro do (& body)
  `((lambda () ~@body))) 

(defmacro when (predicate & body)
  `(if ~predicate (do ~@body)))

(defmacro unless (predicate & body)
  `(if ~predicate nil (do ~@body))) 

;;; IO   
         
(defun println (l)
  (when *stdout* (.WriteLine *stdout* l)))

;;; Conversions

(def int16 System.Convert/ToInt16)
(def short System.Convert/ToInt16)

(def int32 System.Convert/ToInt32)
(def int System.Convert/ToInt32)

(def int64 System.Convert/ToInt64)
(def long System.Convert/ToInt64)

(def string System.Convert/ToString)

;;; Lists

(defun list (& args) args)

(defun first (lst)
  (.First lst))

(defun rest (lst)
  (.Rest lst))

(defun empty? (lst)
  (.IsEmpty lst))

(defun second (lst)
  (first (rest lst)))

(defmacro dolist (binding & body)
  `(let ((list123 ~(second binding))
         (~(first binding) (first list123)))
     (do ~@body)
     (unless (empty? (rest list123))
       (dolist (~(first binding) (rest list123)) ~@body))))
